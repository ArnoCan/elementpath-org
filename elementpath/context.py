# -*- coding: utf-8 -*-
#
# Copyright (c), 2018, SISSA (International School for Advanced Studies).
# All rights reserved.
# This file is distributed under the terms of the MIT License.
# See the file 'LICENSE' in the root directory of the present
# distribution, or http://opensource.org/licenses/MIT.
#
# @author Davide Brunato <brunato@sissa.it>
#
from .exceptions import ElementPathTypeError, ElementPathValueError
from .utils import is_etree_element


class ElementPathContext:
    """
    XPath expressions dynamic context. Testing is done on nodes, items are tested on values
    generated by the parser. Also the static context is provided by the parser.

    :ivar root: The root of the XML document, must be a ElementTree's Element.
    :ivar node: The context node. A `None` value means that the context is positioned on \
    the document node.
    :ivar position: The current position of the node within the input sequence.
    :ivar size: The number of items in the input sequence.
    :ivar variables: Dictionary of context variables that maps a QName to a value.
    """
    def __init__(self, root, node=None, position=0, size=1, variables=None):
        if not is_etree_element(root):
            raise ElementPathTypeError("argument 'root' must be an Element!")
        self.root = root
        self.node = node
        self.position = position
        self.size = size
        self.variables = {} if variables is None else variables
        self._parent_map = None

    def __repr__(self):
        return '%s(root=%r, node=%r, position=%r, size=%r)' % (
            self.__class__.__name__, self.root, self.node, self.position, self.size
        )

    def copy(self, node=None):
        return ElementPathContext(
            root=self.root,
            node=self.node if node is None else node,
            position=self.position,
            size=self.size,
            variables=self.variables.copy()
        )

    def __setattr__(self, name, value):
        if name == 'root':
            if not is_etree_element(value):
                raise ElementPathTypeError("context %s must be an Element: %r" % (name, value))
        elif name == 'node':
            if not is_etree_element(value) and value is not None and not isinstance(value, tuple):
                raise ElementPathTypeError("context %r must be a node(): %r" % (name, value))
        super(ElementPathContext, self).__setattr__(name, value)

    @property
    def parent_map(self):
        if self._parent_map is None:
            self._parent_map = {child: elem for elem in self.root.iter() for child in elem}
        return self._parent_map

    # Node types
    def is_element_node(self):
        return is_etree_element(self.node)

    def is_document_node(self):
        return self.node is None

    def is_attribute_node(self):
        return isinstance(self.node, tuple) and getattr(self.node, '__name__', '') != 'Namespace'

    def is_namespace_node(self):
        return isinstance(self.node, tuple) and getattr(self.node, '__name__', '') == 'Namespace'

    # Node iterators
    def iter_descendants(self):
        def _iter_descendants():
            elem = self.node
            yield self
            if len(elem):
                self.size = len(elem)
                for self.position, self.node in enumerate(elem):
                    for _descendant in _iter_descendants():
                        yield _descendant

        if self.node is None:
            self.size, self.position = 1, 0
            yield self
            self.node = self.root
        elif not is_etree_element(self.node):
            return

        for descendant in _iter_descendants():
            yield descendant

    def iter_children(self):
        if self.node is None:
            self.size, self.position, self.node = 1, 0, self.root
            yield self
        elif is_etree_element(self.node):
            elem = self.node
            self.size = len(elem)
            for self.position, self.node in enumerate(elem):
                yield self

    def iter_ancestors(self):
        if not is_etree_element(self.node):
            return
        elem = self.node
        parent_map = self.parent_map
        while True:
            try:
                parent = parent_map[self.node]
            except KeyError:
                break
            else:
                if parent is elem:
                    raise ElementPathValueError("not a tree, circularity found for node %r." % elem)
                self.node = parent
                yield self
