# -*- coding: utf-8 -*-
#
# Copyright (c), 2018, SISSA (International School for Advanced Studies).
# All rights reserved.
# This file is distributed under the terms of the MIT License.
# See the file 'LICENSE' in the root directory of the present
# distribution, or http://opensource.org/licenses/MIT.
#
# @author Davide Brunato <brunato@sissa.it>
#
from .exceptions import ElementPathTypeError, ElementPathValueError
from .todp_parser import Token


def is_etree_element(element):
    return hasattr(element, 'tag') and hasattr(element, 'attrib') and hasattr(element, 'text')


def is_xpath_node(obj):
    return obj is None or isinstance(obj, tuple) or is_etree_element(obj)


class XPathToken(Token):

    def eval(self, context=None):
        """
        Evaluate from the context.

        :param context: The XPath evaluation context.
        """
        return self.value

    def select(self, context):
        """
        Select operator that generates results

        :param context: The XPath evaluation context.
        """
        yield self.eval(context)

    def __str__(self):
        symbol = self.symbol
        if symbol == '$':
            return '$%s variable reference' % str(self[0].eval())
        elif symbol.endswith('(') and symbol[:-1].isalpha():
            return '%s(%s) function' % (symbol[:-1], ', '.join(repr(t.value) for t in self))
        elif symbol.endswith('::') and symbol[:-2].isalpha():
            return '%s axis' % self.symbol[:-2]
        return super(XPathToken, self).__str__()

    # Helper methods
    def node_filter(self, node):
        if not is_xpath_node(node):
            self.wrong_type("an XPath node required")
        return node

    def boolean(self, value):
        """The effective boolean value, computed by fn:boolean()."""
        if isinstance(value, list):
            if not value:
                return False
            elif is_xpath_node(value[0]):
                return True
            elif len(value) > 1:
                self.wrong_type("not a test expression")
            else:
                return bool(value[0])
        elif is_xpath_node(value):
            self.wrong_type("not a test expression")
        else:
            return bool(value)


class XPathContext:
    """
    XPath expressions dynamic context. Testing is done on nodes, items are tested on values
    generated by the parser. Also the static context is provided by the parser.

    :ivar root: The root of the XML document, must be a ElementTree's Element.
    :ivar node: The context node. A `None` value means that the context is positioned on \
    the document node.
    :ivar position: The current position of the node within the input sequence.
    :ivar size: The number of items in the input sequence.
    :ivar variables: Dictionary of context variables that maps a QName to a value.
    """
    def __init__(self, root, node=None, position=0, size=1, variables=None):
        if not is_etree_element(root):
            raise ElementPathTypeError("argument 'root' must be an Element!")
        self.root = root
        self.node = node
        self.position = position
        self.size = size
        self.variables = {} if variables is None else variables
        self._parent_map = None

    def __repr__(self):
        return '%s(root=%r, node=%r, position=%r, size=%r)' % (
            self.__class__.__name__, self.root, self.node, self.position, self.size
        )

    def copy(self, node=None):
        return XPathContext(
            root=self.root,
            node=self.node if node is None else node,
            position=self.position,
            size=self.size,
            variables=self.variables.copy()
        )

    def __setattr__(self, name, value):
        if name == 'root':
            if not is_etree_element(value):
                raise ElementPathTypeError("context %s must be an Element: %r" % (name, value))
        elif name == 'node':
            if not is_xpath_node(value):
                raise ElementPathTypeError("context %r must be a node(): %r" % (name, value))
        super(XPathContext, self).__setattr__(name, value)

    @property
    def parent_map(self):
        if self._parent_map is None:
            self._parent_map = {child: elem for elem in self.root.iter() for child in elem}
        return self._parent_map

    # Node types
    def is_element_node(self):
        return is_etree_element(self.node)

    def is_document_node(self):
        return self.node is None

    def is_attribute_node(self):
        return isinstance(self.node, tuple) and getattr(self.node, '__name__', '') != 'Namespace'

    def is_namespace_node(self):
        return isinstance(self.node, tuple) and getattr(self.node, '__name__', '') == 'Namespace'

    # Node iterators
    def iter_descendants(self):
        def _iter_descendants():
            elem = self.node
            yield self
            if len(elem):
                self.size = len(elem)
                for self.position, self.node in enumerate(elem):
                    for _descendant in _iter_descendants():
                        yield _descendant

        if self.node is None:
            self.size, self.position = 1, 0
            yield self
            self.node = self.root
        elif not is_etree_element(self.node):
            return

        for descendant in _iter_descendants():
            yield descendant

    def iter_children(self):
        if self.node is None:
            self.size, self.position, self.node = 1, 0, self.root
            yield self
        elif is_etree_element(self.node):
            elem = self.node
            self.size = len(elem)
            for self.position, self.node in enumerate(elem):
                yield self

    def iter_ancestors(self):
        if not is_etree_element(self.node):
            return
        elem = self.node
        parent_map = self.parent_map
        while True:
            try:
                parent = parent_map[self.node]
            except KeyError:
                break
            else:
                if parent is elem:
                    raise ElementPathValueError("not a tree, circularity found for node %r." % elem)
                self.node = parent
                yield self
